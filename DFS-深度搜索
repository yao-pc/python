"""
核心思想
一路走到黑：从起始点开始，沿着一条路径尽可能深地探索，直到到达末端（没有未访问的邻接点）。
回溯：当到达末端后，后退一步（回溯），尝试另一条未走过的路径。
递归与栈：这个过程天然地适合用递归来实现，因为递归本身就是利用函数调用栈来记录状态。当然，你也可以显式地使用栈（Stack） 这种数据结构来模拟这个过程。

路径查找：检查两个节点之间是否存在路径。
拓扑排序：用于有向无环图（DAG）的排序。
检测图中的环：特别是在有向图中。
解决迷宫问题：DFS是走迷宫的一种自然策略。
回溯算法的基础：许多复杂问题（如八皇后、数独）的求解都基于DFS的回溯思想。
"""

def solve_maze(maze, start, end):
    rows, cols = len(maze), len(maze[0])
    visited = [[False for _ in range(cols)] for _ in range(rows)]
    path = []

    def dfs(x, y):
        # 首先检查是否到达终点
        if (x, y) == end:
            path.append((x, y))
            return True

        # 然后检查边界和有效性
        if x < 0 or x >= rows or y < 0 or y >= cols or maze[x][y] == 1 or visited[x][y]:
            return False

        visited[x][y] = True
        path.append((x, y))

        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            if dfs(x + dx, y + dy):
                return True

        path.pop()
        return False

    if dfs(start[0], start[1]):
        return path
    else:
        return None


# 示例迷宫
maze = [
    [2, 0, 1, 0, 0],
    [1, 0, 1, 0, 1],
    [0, 0, 0, 0, 1],
    [1, 1, 0, 1, 1],
    [0, 0, 0, 0, 3]
]

start = (0, 0)
end = (4, 4)
result = solve_maze(maze, start, end)
print(result)


# [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)]

