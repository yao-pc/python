"""
BFS使用队列，按照"先进先出"的原则处理节点
遍历顺序是层级式的，先访问所有距离相同的节点，再访问下一层
一定能找到最短路径（在无权图中），这是BFS的最大优势
空间开销较大，特别是在宽度很大的图中
"""

from collections import deque

def bfs(graph, start_node):
    """
    :param graph: 以邻接表形式表示的图
    :param start_node: 起始节点
    """
    # 创建已访问集合和队列
    visited = set()
    queue = deque([start_node])
    visited.add(start_node)

    while queue:
        # 取出队首节点
        node = queue.popleft()
        print(node, end=' ')  # 处理当前节点

        # 将所有未访问的邻居加入队列
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)


# 示例图的邻接表（与DFS示例相同）
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A'],
    'D': ['B'],
    'E': ['B']
}

print("BFS遍历顺序：")
bfs(graph, 'A')
# 输出： A B C D E

